<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Jump</title>
    <link href="css/style.css" rel="stylesheet">
</head>

<body onload="init();">
    <div id="content-wrap">
        <div id="content">
            <canvas id="gameCanvas" width="960" height="600"></canvas>
        </div>
    </div>
    <script src="lib/preloadjs-NEXT.min.js"></script>
    <script src="lib/easeljs-NEXT.combined.js"></script>
    <script src="js/ball.js"></script>
    <script src="js/platform.js"></script>
    <script src="js/utils.js"></script>
    <script>
var PLATFORM_HEIGHT = 8;
var BALL_SIZE = 12;
var ROWS = 200;
var COLUMNS = 20;
var ROW_HEIGHT = 320;
var COLUMN_WIDTH = 500;
var canvas;
var w;
var h;
var stage;
var world;
var grid;
var worldWidth;
var worldHeight;
var platforms;
var collisionTarget;
var ball;
var round;
var difficulty;
var distanceField;
var messageField;
var roundField;
var jumpField;
var jumpSubField;
var gravityField;
var jumpHeld;
var diveHeld;
var nextRound;

document.onkeydown = handleKeyDown;
document.onkeyup = handleKeyUp;
document.onmousedown = handleKeyDown;
document.onmouseup = handleKeyUp;

function init() {
    canvas = document.getElementById("gameCanvas");
    w = canvas.scrollWidth;
    h = canvas.scrollHeight;
    stage = new createjs.Stage(canvas);
    world = new createjs.Container();

    stage.addChild(world);


    startBall = new createjs.Shape();
		startBall.graphics.setStrokeStyle(2).beginRadialGradientFill(["rgb(255, 255, 255)", "rgba(255, 0, 84, 1)"], [0, 1], 24, 48, 0, 18, 48, 24).drawCircle(36, 72, 72);
    startBall.x = w *.2;
    startBall.y = h * .4;
    messageField = new createjs.Text("0", "italic 16px 'Helvetica Neue'", "#000000");
    messageField.textAlign = "left";
    messageField.lineHeight = 30;
    messageField.x = w * 0.4;
    messageField.y = h * 0.8;
    messageField.maxWidth = w;

    roundField = new createjs.Text("0", "bold italic 16px 'Helvetica Neue'", "#000000");
    roundField.textAlign = "right";
    roundField.x = w - 40;
    roundField.y = h - 10;
    roundField.maxWidth = 1000;

    jumpField = new createjs.Text("0", "bold 48px 'Helvetica Neue'", "#ff004c");
    jumpField.textAlign = "right";
    jumpField.x = w - 40;
    jumpField.y = h - 40;
    jumpField.maxWidth = 1000;

    jumpSubField = new createjs.Text("0", "bold 10px 'Helvetica Neue'", "#969696");
    jumpSubField.textAlign = "right";
    jumpSubField.x = w - 39;
    jumpSubField.y = h - 88;
    jumpSubField.maxWidth = 1000;

    gravityField = new createjs.Text("0", "italic 10px 'Helvetica Neue'", "#9f9f9f");
    gravityField.textAlign = "right";
    gravityField.x = w - 40;
    gravityField.y = h - 30;
    gravityField.maxWidth = 1000;

    distanceField = new createjs.Text("0", "bold italic 16px 'Helvetica Neue'", "#6e6e6e");
    distanceField.textAlign = "right";
    distanceField.x = w - 160;
    distanceField.y = h - 4;
    distanceField.maxWidth = 1000;



    stage.addChild(messageField, startBall);
    messageField.scaleY = -1;
    messageField.text = "Hello!, I am a ball,\n and I simply love bouncing! \n\n I generally get much more height from\n a good bounce than a boring jump.\n\n\n (click)";
    stage.update();
    canvas.onclick = newGame;
}

function newGame() {
  canvas.onclick = null;
  messageField.text = "I have a huge favor to ask...\n\nCould you help me get all \nthe way to the top of this level? \nWhy? Shut up and help me\n\n\n (click)";
  stage.update();

canvas.onclick = newGame2;


}

function newGame2() {
  canvas.onclick = null;
  messageField.text = "Okay so listen up! \n\nTo make me jump, press up \nTo make me dive into a bounce, press down\nOh yeah, I can jump while midair, \nbut .. I get tired easily,\nso keep an eye on how many more times I can jump.\nI think that's it... Good luck!\n\n\n(click to start)";
  stage.update();

  canvas.onclick = handleClick;
}

function retry() {
  if (createjs.Ticker.hasEventListener("tick")) {
      createjs.Ticker.removeEventListener("tick", tick);
  }
  messageField.text = "Try again (click)";
  stage.addChild(messageField);

  canvas.onclick = restart;
}


function handleClick() {
    canvas.onclick = null;
    stage.removeChild(startBall);
    stage.removeChild(messageField);
    restart();
}

function restart() {
    stage.removeChild(messageField);
    world.removeAllChildren();
    difficulty = 10;
    nextRound = 1000;
    round = 1;
    roundField.text = "";
    distanceField.text = "";
    jumpField.text = "";
    jumpSubField.text = "jumps";
    gravityField.text = "";
    jumpHeld = false;
    diveHeld = false;

    setAssets();
    if (!createjs.Ticker.hasEventListener("tick")) {
        createjs.Ticker.addEventListener("tick", tick);
    }
    createjs.Ticker.setFPS(60);
}

function setAssets() {
  stage.addChild(distanceField, roundField, jumpField, jumpSubField, gravityField);
  roundField.scaleY = -1;
  distanceField.scaleY = -1;
  jumpField.scaleY = -1;
  jumpSubField.scaleY = -1;
  gravityField.scaleY = -1;
    world.x = 0;
    world.y = 0;
    var setPlatform = false;
    var rn, p, startX, startY, gapX, gapY, pX, pY, addChance, totalChance;
    grid = [];
    platforms = [];
    worldWidth = 0;
    for (var x = 0; x <= COLUMNS; x++) {
        grid[x] = [];
        for (var y = 0; y <= ROWS; y++) {
            if (Math.random() > 0.5) {
                grid[x][y] = true;
            } else {
                grid[x][y] = false;
            }
        }
    }
    for (var x = 1; x <= COLUMNS; x++) {
        addChance = 200;
        totalChance = 100;
        grid[x] = [];
        rn = Math.random() * 100.0;
        if (rn < 50.0) {
            grid[x][0] = true;
        } else {
            grid[x][0] = false;
        }
        if (rn > 50.0) {
            grid[x][ROWS + 1] = true;
        } else {
            grid[x][ROWS + 1] = false;
        }
        for (var y = 1; y <= ROWS; y++) {
            grid[x][y] = true;
            rn = Math.random() * totalChance;
            if (grid[x][y - 1]) {
                if (grid[x - 1][y - 1] && grid[x - 1][y] && grid[x - 1][y + 1]) {
                    if (rn < addChance * 2.0) {
                        grid[x][y] = false;
                    }
                } else {
                    if (grid[x - 1][y - 1] && grid[x - 1][y]) {
                        if (rn < addChance / 4) {
                            grid[x][y] = false;
                        }
                    } else if (grid[x - 1][y] && grid[x - 1][y + 1]) {
                        if (rn < addChance * 1.5) {
                            grid[x][y] = false;
                        }
                    } else if (grid[x - 1][y - 1] && grid[x - 1][y + 1]) {
                        if (rn < addChance / 2) {
                            grid[x][y] = false;
                        }
                    } else if (grid[x - 1][y]) {
                        if (rn < addChance / 4) {
                            grid[x][y] = false;
                        }
                    }
                }
            } else if (rn > addChance) {
                if (grid[x - 1][y - 1] && grid[x - 1][y] && grid[x - 1][y + 1]) {
                    if (rn < addChance) {
                        grid[x][y] = false;
                    }
                } else if (grid[x - 1][y] && grid[x - 1][y + 1]) {
                    if (rn < addChance) {
                        grid[x][y] = false;
                    }
                }
            }
            if (!grid[x][y]) {
                startX = x * COLUMN_WIDTH;
                startY = y * ROW_HEIGHT;
                pX = Math.random() * (COLUMN_WIDTH);
                pY = Math.random() * (ROW_HEIGHT);
                gapX = COLUMN_WIDTH - pX;
                gapY = ROW_HEIGHT - pY;
                if (x % 2 === 0) {
                    startX += gapX;
                    startY += (gapY + .5*ROW_HEIGHT);
                } else {
                    startX += gapX;
                    startY -= (gapY + .5*ROW_HEIGHT);
                }
                addChance *= 0.85;
                p = new Platform(startX, startY, difficulty, 0, pX + (.6* COLUMN_WIDTH), PLATFORM_HEIGHT, x, y);
                platforms.push(p);
                world.addChild(p);
            } else {}
        }
    }
    platforms.forEach(function(platform) {
        // console.log("(" + platform.x + "," + platform.y + ")");
    });
    worldWidth += COLUMN_WIDTH * COLUMNS;
    worldHeight = ROW_HEIGHT * ROWS;
    ball = new Ball(BALL_SIZE);

    ball.x = 200;
    ball.y = 200;
    stage.clear();
    stage.update();
    world.addChild(ball);
    if (createjs.Ticker.hasEventListener("tick")) {
        createjs.Ticker.removeEventListener("tick", tick);
    }
    // world.scaleX = 0.03;
    // world.scaleY = 0.03;
}

function tick(event) {
    if (jumpHeld) {
        ball.jump();
    } else if (diveHeld) {
        ball.dive();
    } else {
        ball.releaseJump();
    }
    worldY = (0.5 * h) - ball.y;
    var diff = Math.abs(worldY - world.y);
    if (diff > 20) {
        if (world.y < worldY) {
            world.y += 10 * (diff / 80);
        } else if (world.y >= worldY) {
            world.y -= 10 * (diff / 80);
        }
    }
    collisionTarget = null;
    platforms.forEach(function(platform) {
        platform.tick(event);
        if (!collisionTarget && ball.t > 0.1) {
            if (ball.x < platform.x + platform.sizeX + difficulty) {
                if (ball.x > platform.x - difficulty - ball.size) {
                    if (ball.y > platform.y + platform.sizeY) { // fall on
                        if (ball.y + (ball.dY) < platform.y + platform.sizeY && ball.dY < 0) {
                            collisionTarget = platform;
                        }
                    } else if (ball.y + ball.size < platform.y && ball.dY > 0) { // bounce into
                        if (ball.y + ball.size + ball.dY > platform.y) {
                            collisionTarget = platform;
                        }
                    } else if (ball.y - 10 < platform.y + platform.sizeY && ball.y > platform.y + platform.sizeY - 2) {
                        collisionTarget = platform;
                    }
                }
            }
        }
        if (platform.x < 0 - platform.sizeX) {
            platform.reposition(worldWidth, difficulty);
        }
    });
    if (collisionTarget) {
        ball.hit(collisionTarget);
    }
    if (ball.y < -1000) {
        retry();
    }
    nextRound -= 1;
    if (nextRound % 100 === 0) {
        ball.recognizeAltitude(worldHeight);
    }


    if (nextRound <= 0) {
        round += 1;
        nextRound = 1000;
        increaseDifficulty();
    }
    roundField.text = "Round: " + round;
    distanceField.text = Math.floor((worldHeight - ball.y) / 100) + " to go";
    jumpField.text = ball.jumps + "";
    gravityField.text = "Gravity: " + (ball.a * 10).toFixed(1);
    ball.tick(event);
    stage.update(event);
}

function increaseDifficulty() {
    platforms.forEach(function(platform) {
        platform.increaseSpeed();
    });
}

function addPlatformSlope() {
    platforms.forEach(function(platform) {
        platform.vY = -1;
    });
}

function removePlatformSlope() {
    platforms.forEach(function(platform) {
        platform.vY = 0;
    });
}



function handleKeyDown(e) {
    switch (e.keyCode) {
        case 80:
            if (createjs.Ticker.hasEventListener("tick")) {
                createjs.Ticker.removeEventListener("tick", tick);
            } else {
                createjs.Ticker.addEventListener("tick", tick);
            }
            break;
        case 87:
            if (!jumpHeld) {
                jumpHeld = true;
                diveHeld = false;
            }
            break;
        case 38:
            if (!jumpHeld) {
                jumpHeld = true;
                diveHeld = false;
            }
            break;
        case 83:
            if (!diveHeld) {
                diveHeld = true;
                jumpHeld = false;
            }
            break;
        case 40:
            if (!diveHeld) {
                diveHeld = true;
                jumpHeld = false;
            }
            break;
        default:
            jumpHeld = false;
            diveHeld = false;
            break;
    }
}

function handleKeyUp(e) {
    jumpHeld = false;
    diveHeld = false;
}
    </script>
</body>

</html>
